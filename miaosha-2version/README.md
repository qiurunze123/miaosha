秒杀商品实体对象
商品信息、订单信息、用户信息
秒杀注意事项
商品秒杀在指定时间内以超低价销售某种商品，那么在
秒杀阶段就会产生大量用户的并发请求，系统如何抗住
如此并发量是保证系统稳定的基石。而且应该注意并发点
是在商品秒杀的前期，即商品下单的过程中。具体为：
1）请求商品库存信息（读请求）
1 可以先校验库存，再扣减库存；也可以直接decr原子操作通过返回值判断商品是否售罄
2 对于量不大的秒杀商品，也可以使用redis中的list数据结构，提前将库存量一个一个加进去，
                    在秒杀的时候，直接从list中pop出来
3 秒杀的真正并发量在于前期的秒杀校验中（包括地址校验、库存校验、重复下单校验），因此在前期
将这些请求放入对列中，可以提高系统并发度。目前绝大多数秒杀的系统在这一步骤中都是使用的同步
请求，这样导致并发度并不高。
2）创建秒杀订单（写请求）
3）订单成功创建通知
4）订单支付通知
系统稳定的关键在于在请求商品的库存信息时候，如何保证系统不宕机
1）假设系统请求的并发量为10000000qps
2）对于redis的qps为100000，那么就需要10个redis系统
3）一旦存在库存，就可以下订单，这个过程实际并发量不高
4）如果1000000qps直接打到mysqlDb的话，db会崩溃，因为我们知道
mysql的qps仅为1万+。所以请求不能达到db上。因此我们会将库存信息同步到
redis缓存中。
5）虽然redis的qps大于db的qps一个量级，但是对于千万级的qps也是显得新犹如而力不足。
6）如何让redis能够抗住千万计的qps就成为了我们设计的难点。
7）在并发情况下如何防止超卖也是系统设计需要考虑的问题。
对于第6点的解决方案有：
1）使用redis限流，比如限制qps为1万
2）使用redis集群，
3）将请求放入到消息队列中
4）每个用户限制秒杀一次

对于第7点的解决方案：
1）商品超卖主要是高并发引起的，因此可以将扣减库存信息使用锁机制解决
2）可以将库存信息保存在redis中，由于redis是单进程的，所有的请求都会排队
放入队列中，因此不会出现并发操作。
3）使用消息队列解决。


秒杀项目架构图




开发记录
1）对已有的秒杀接口进行优化(已完成)
2）添加订单支付接口服务,使用远程服务接口调用(已完成)
3）订单成功生成后，同步缓存与数据库的库存信息(已完成)
1 生成订单减库存；取消订单增库存，并且同步缓存信息。这部分需要保证原子操作，因此使用分布式锁完成。(已完成)
2 由于秒杀系统的特殊性，这里的同步不适合使用双删策略，即先删除缓存，再更新数据库，其次再次删除缓存。这一过程
需要保证原子操作（步骤要么都执行，要么都不执行）
4) 对于秒杀系统引入分布式事务
5）对秒杀接口再次优化，提升并发量
5.1 在redis缓存中查询秒杀商品库存时，将库存量分段存储。比如某个商品的
库存为1000，可以存储10的缓存，每个缓存的库存量为100，这样就可以提高并发量。为什么，能从redis缓存原理解释吗？
这与redis的io多路复用有关，减少阻塞，提高并发度。
5.2 对redis作主从配置，提高redis的并发量（已完成）
6) 对消息对列接口进行优化，兼容rocketmq等消息中间件（已完成）
6.1 订单延时消息的发送与接收
6.2 订单支付成功消息回调
6.3 订单秒杀请求转发
使用抽象工厂还是工厂方法模式？
抽象工厂：对象构建型，掩藏对象创建的具体方法。由抽象工厂、具体工厂、抽象产品和具体产品四要素组成
不需要修改工厂接口，符合开闭原则。符合依赖倒置原则

工厂方法：对象构建型，每次增加新的产品，都会修改工厂接口，违背了开闭原则。

7) redis接口优化
整合spring和redis(已完成)

8）分布式锁创建注意要点
1  使用原子操作对变量设置值，初始值为0，获取锁后值修改为1
2  释放锁的时候只需将变量值设置为0即可
3  使用锁的时候要注意设置锁变量的过期时间，避免应用系统宕机后无法释放锁
9）增加积分服务
  对于用户成功支付订单后，需要给用户增加响应的积分。积分金额暂定为用户消费总金额*10。
  另外开发一个积分系统，专门记录用户的积分情况。因此这里需要使用到分布式事务的相关知识。







