秒杀商品实体对象
商品信息、订单信息、用户信息
秒杀注意事项
商品秒杀在指定时间内以超低价销售某种商品，那么在
秒杀阶段就会产生大量用户的并发请求，系统如何抗住
如此并发量是保证系统稳定的基石。而且应该注意并发点
是在商品秒杀的前期，即商品下单的过程中。具体为：
1）请求商品库存信息（读请求）
1 可以先校验库存，再扣减库存；也可以直接decr原子操作通过返回值判断商品是否售罄
2 对于量不大的秒杀商品，也可以使用redis中的list数据结构，提前将库存量一个一个加进去，
                    在秒杀的时候，直接从list中pop出来
2）创建秒杀订单（写请求）
3）订单成功创建通知
4）订单支付通知
系统稳定的关键在于在请求商品的库存信息时候，如何保证系统不宕机
1）假设系统请求的并发量为10000000qps
2）对于redis的qps为100000，那么就需要10个redis系统
3）一旦存在库存，就可以下订单，这个过程实际并发量不高
4）如果1000000qps直接打到mysqlDb的话，db会崩溃，因为我们知道
mysql的qps仅为1万+。所以请求不能达到db上。因此我们会将库存信息同步到
redis缓存中。
5）虽然redis的qps大于db的qps一个量级，但是对于千万级的qps也是显得新犹如而力不足。
6）如何让redis能够抗住千万计的qps就成为了我们设计的难点。
7）在并发情况下如何防止超卖也是系统设计需要考虑的问题。
对于第6点的解决方案有：
1）使用redis限流，比如限制qps为1万
2）使用redis集群，
3）将请求放入到消息队列中
4）每个用户限制秒杀一次

对于第7点的解决方案：
1）商品超卖主要是高并发引起的，因此可以将扣减库存信息使用锁机制解决
2）可以将库存信息保存在redis中，由于redis是单进程的，所有的请求都会排队
放入队列中，因此不会出现并发操作。
3）使用罅隙队列解决。


秒杀项目架构图




开发记录
1）对已有的秒杀接口进行优化(已完成)
2）添加订单支付接口服务,使用远程服务接口调用(已完成)
3）订单成功生成后，同步缓存与数据库的库存信息(已完成)
生成订单减库存；取消订单增库存，并且同步缓存信息。这部分需要保证原子操作，因此使用分布式锁完成。(未完成)
4) 对于秒杀系统引入分布式事务
5）对秒杀接口再次优化，提升并发量
5.1 在redis缓存中查询秒杀商品库存时，将库存量分段存储。比如某个商品的
库存为1000，可以存储10的缓存，每个缓存的库存量为100，这样就可以提高并发量。为什么，能从redis缓存原理解释吗？
5.2 对redis作主从配置，提高redis的并发量
6) 对消息对列接口进行优化，兼容rocketmq等消息中间件
6.1 订单延时消息的发送与接收
6.2 订单支付成功消息回调
6.3 订单秒杀请求转发
使用抽象工厂还是工厂方法模式？
抽象工厂：对象构建型，掩藏对象创建的具体方法。由抽象工厂、具体工厂、抽象产品和具体产品四要素组成
不需要修改工厂接口，符合开闭原则。符合依赖倒置原则

工厂方法：对象构建型，每次增加新的产品，都会修改工厂接口，违背了开闭原则。

7) redis接口优化
整合spring和redis




