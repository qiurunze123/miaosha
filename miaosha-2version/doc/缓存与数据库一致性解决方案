缓存与数据库一致性的解决方案分为两种
1 懒加载
就是说在查询业务库的时候才将数据加载到缓存中。
一般采用的方法是延迟双删+懒加载+缓存过期、mq
写线程
1 删除缓存
2 更新数据库，线程休眠
3 删除缓存
4 第3步删除失败，删除失败重试
读线程
1 读缓存
2 缓存没有，读db
3 写入缓存
备注：
其中重试机制有两种，一种是在现有业务代码中直接嵌入重试代码；一种是订阅mysql的binlog（cannel），对于有主从集群的应用时，要订阅从库的binlog，解析出修改的数据记录和key，然后放入
mq中去异步消费。
对于缓存击穿问题，目前的思路是当查询缓存不存在时，加入锁资源，然后再访问数据库，防止出现大量线程并发访问数据库。
2 主动加载
就是在更新数据库之后，就更新缓存。
写线程
1 删除缓存
2 更新数据库
3 更新缓存
读线程
1 读缓存
2 缓存没有，读db
3 更新缓存
备注：

在这种模式下可能会发生并发读写ABBA问题（读线程写到缓存的是旧数据），因此在这里需要保证写线程3、4步是一个原子操作，
读线程2/3也是原子操作。在这里有开发人员提出可以加一把分布式读写锁。读锁可以叠加，但不能加写锁。而写锁具有排他性，
一旦加入写锁，就不能再次加入写锁、读锁。还有就是对于写线程而言，在执行完2步之后，将查新数据+更新缓存加入mq串行化执行，
对于读线程而言，将查数据和更新缓存也加入mq串行化执行，这样就能避免读写覆盖问题。




