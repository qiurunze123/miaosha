分布式锁的特点：
1）可重入
同一节点同一线程获取锁资源后可以再次获取
2）排它性
某个节点的线程获取锁资源后，其它节点的线程需等待。
3）高可用
锁节点故障后，其它节点的锁资源能够继续使用
4）锁超时
锁资源应设置超时机制，防止所服务故障后，锁资源一直不能释放。
5） 阻塞与非阻塞
提供trylock（）和lock（）方法。
6） 公平和非公平机制
公平：节点按照先到先得的约定轮流获取锁资源，当一个节点获取所资源后，其它节点按序到等待对列中等待；
非公平：各个节点抢占式地获取锁资源。新来的节点和原来的节点共同竞争锁资源。
分布式锁实现方式
1） mysql
1.1 基于数据库表作唯一性约束（方法名为唯一约束建）
当要锁住某资源时，插入一条记录，这样当多个节点并发访问时，由于唯一性约束导致只有一个节点能操作成功。
当腰释放资源时，直接删除该条记录。
缺点：非阻塞、非重入、无失效时间、无高可用
1.2 基于数据库表作悲观锁（for update）
在查询语句后面添加for update，那么mysql就会为该记录加上排它锁。如果该语句执行成功，就可以认为获取排他锁的
线程获取分布式锁，其它节点就会被阻塞直至超时返回。这里提一句，只有建立索引的字段检索时才会加行锁。非索引字段检索
加表锁。
缺点：无法解决可重入问题。

1.3 基于数据库表作乐观锁（version）
先查数据库再更新数据库；
select version from XXXX；update XXXX set xxx=xxx and version=version+1 where version=xxx；
 A. 先执行SELECT操作查询当前数据的数据版本号,比如当前数据版本号是26：
  SELECT ID, RESOURCE, STATE,VERSION FROM T_RESOURCE WHERE STATE=1 AND ID=5780;
  B. 执行更新操作：
  UPDATE T_RESOURE SET STATE=2, VERSION=27, UPDATE_TIME=NOW() WHERE RESOURCE=XXXXXX AND
  STATE=1 AND VERSION=26
  C. 如果上述UPDATE语句真正更新影响到了一行数据，那就说明占位成功。如果没有更新影响到一行数据
  ，则说明这个资源已经被别人占位了。
缺点：操作次数变多了，一次select，一次update；多个资源都需要用保证数据一致性，那么如果全部使用基于数据库资源表的乐观锁，就要让每个资源都有一张资源表，这个在实际使用场景中肯定是无法满足的


优点:理解起来简单，不需要维护额外的第三方中间件(比如Redis,Zk)。
缺点:虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。


2） redis
加锁：set resource_name my_random_value nx px 30000
释放锁: if redis.call('get',keys[1])==argvs[1] then
    redis.call('del',keys[1])
        else
           return 0
redis不过期，就会导致一旦拥有锁的节点线程挂掉或者崩溃，没有释放锁，其它节点线程就一直阻塞，无法继续向下运行。
redis超时过期--》多节点并发拥有锁资源
2.1 如果my_random_value设置客户端唯一标识码，那么久可以避免当前节点不会删除其它节点的锁资源，
那么最多有2个节点访问锁资源
2.2 如果my_random_value不设置客户端唯一标识码，那么就会导致多个（多于3个）节点并发访问锁资源
锁超时过期问题，就会导致多个节点并发对业务进行操作，拥有过期锁的节点线程可能会覆盖其它节点线程的业务操作。
实现方案有：Redission


3） zookeeper
实现方案有Curator、InterProcessMutex
每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的临时有
序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。
当释放锁的时候，只需将这个临时节点删除即可。同时，排队的节点需要监听排在自己之前的节点，这样能
在节点释放时候接收到回调通知，让其获得锁。zk的session由客户端管理，其可以避免服务宕机导致的锁无
法释放，而产生的死锁问题，不需要关注锁超时。
优点:ZK可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，ZK获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用ZK集群进行保证。
缺点:ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么。


